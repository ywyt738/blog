<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[四招美化click命令行应用]]></title>
    <url>%2F2019%2F05%2F13%2F%E5%9B%9B%E6%8B%9B%E7%BE%8E%E5%8C%96click%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[python在实现命令行工具的方面有很多有优势的库，其中Click是其中的佼佼者。 今天不是Click的教学，参考官方文档就可以很快写出一个不错的命令行应用。今天我们来做四件事提高我们命令行应用的B格： 长时间任务的等待效果 命令行帮助的文档的美化 错误命令猜测提示 日志级别的控制 快速实现一个等待效果 在很多命令行工具的交互过程中存在着长时间等待一些任务，如果没有一些友好的提示，经常会被使用者认为卡死或者死循环等情况。而进度条是一个非常不错的解决方案，progressbar，progressive都是不错的选择, click也有自己的click.progressbar。但是遇到总体进度预先不知道的任务，例如：等待某个任务完成、等待数据加载等这些不知道什么时候才能完成的任务的时候进度条就不那么好用了。这个时候最简单的一个表示方式就是循环动画播放，比如iOS中的“转菊花”。 你可以自己写一个异步的动画播放效果，这里我就不写了。我今天要用非常简单的方法来实现这一效果，我们用到的是blindspin，一个click-spinner的fork，没什么大变化主要是动画效果不一样。 安装 pip install blindspin spinner.pyimport timeimport clickimport blindspindef a_long_time_task(): """模拟一个需要等待的任务""" time.sleep(5)@click.command()def cli(): # 将长时间的任务放在这个with语句中就可以了 # with中执行的任务全部结束，动画效果就会结束 with blindspin.spinner(): a_long_time_task()if __name__ == "__main__": cli() 效果: 美化帮助文档click能够非常方便的生成帮助文档，通过命令行参数--help就能查看到。默认的帮助文档是一色的，现在我们来给它上色吧。 安装 pip install click-help-colors 这里我就用官网的例子，稍稍改一点点，自己体会一下就会用了。 colour_help.pyimport clickfrom click_help_colors import HelpColorsGroup, HelpColorsCommand@click.group( cls=HelpColorsGroup, help_headers_color='yellow', help_options_color='magenta')def cli(): """主命令""" pass@cli.command()@click.option('--count', default=1, help='Some number.')def command1(count): click.echo('command 1')@cli.command(cls=HelpColorsCommand, help_options_color='blue')@click.option('--name', help='Some string.')def command2(name): click.echo('command 2')if __name__ == "__main__": cli() 效果 python colour_help.py --help python colour_help.py command1 --help python colour_help.py command2 --help 猜测用户希望的命令当我们子命令比较多的时候，用户可能会记错、拼错或者打错。能提示用户正确的命令那是多么cool的一件事，然而我们经常用的git就有这样的功能。 这里我输错push命令，git提示我们正确的写法。这个功能已经有人帮我们实现了，就是click-didyoumean 安装 pip install click-didyoumean 用法 为你的命令组指定DYMGroup类 import clickfrom click_didyoumean import DYMGroup@click.group(cls=DYMGroup)def cli(): pass@cli.command()def foo(): pass@cli.command()def bar(): pass@cli.command()def barrr(): passif __name__ == "__main__": cli() 将需要的子命令放入DYMCommandCollection中 import clickfrom click_didyoumean import DYMCommandCollection@click.group()def cli1(): pass@cli1.command()def foo(): pass@cli1.command()def bar(): pass@click.group()def cli2(): pass@cli2.command()def barrr(): passcli = DYMCommandCollection(sources=[cli1, cli2])if __name__ == "__main__": cli() DYMGroup和DYMCommandCollection类有两个配置项， 参数 类型 默认值 描述 max_suggestions int 3 最大建议条目数 cutoff float 0.5 小于这个可能性分数的将会被忽略 例： @cli.group(cls=DYMGroup, max_suggestions=2, cutoff=0.7)def cli(): pass... or ...cli = DYMCommandCollection(sources=[cli1, cli2], max_suggestions=2, cutoff=0.7) 这里有个小插曲，如果你想同时使用click-help-colors和click-didyoumean，那么你会发现他们都需要对cls参数进行修改。怎么同时让两者都生效呢？这里可以使用python的多重继承功能。 class CLI(DYMGroup, click_help_colors.HelpColorsGroup): pass@click.group( cls=CLI, help_headers_color='yellow', help_options_color='blue')def cli(): pass 这样我们就能使得我们的命令行应用同时具备着两种功能了👍。 用户指定日志等级我们经常有这样的情况，希望日志等级可以通过参数的传入来控制。比如，默认情况只输出一下必要信息。加入参数-v可以显示更多详细信息。 通常情况我们可以这样实现： import logginglogger = logging.getLogger(__name__)@click.command()@click.option('--verbose', '-v', default=False, is_flag=True)def cli(verbose): if verbose: logger.setLevel(logging.ERROR) else: logger.setLevel(logging.INFO) logger.info("普通输出信息") logger.error("详细信息") 然而click-log已经为我们实现了这一功能，使用python最大的好处就是DRY(Don’t repeat yourself) 安装 pip install click-log 这里我们仅仅演示基本的做法，更多自定义的内容请参考官方文档 import loggingimport click_loglogger = logging.getLogger(__name__)click_log.basic_config(logger)@click.command()@click_log.simple_verbosity_option(logger)def cli(): logger.info("Dividing by zero.") try: 1 / 0 except: logger.error("Failed to divide by zero.") 以上代码，中click_log.simple_verbosity_option装饰器为命令增加了一个--verbosity可选参数，它接受DEBUG,INFO,WARNING,ERROR或者CRITICAL这几个值来控制日志级别。 好了以上就是我们用来美化click命令行应用的四招。]]></content>
      <tags>
        <tag>python</tag>
        <tag>cli</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写一个python装饰器]]></title>
    <url>%2F2019%2F04%2F28%2F%E5%86%99%E4%B8%80%E4%B8%AApython%E8%A3%85%E9%A5%B0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[装饰器的用途装饰器的主要作用在于对现有方法、函数进行一定的扩展，简单的说就是在原有函数、方法调用前、后去添加一些额外的功能。至于更高层次的用法，我们就不深讨论了。今天只说一些简单的。 结论先出结论，装饰器的写法是有一定规律的，可以按照以下 公式 来套用。 from functools import wrapsdef decorate(func): @wraps(func) def wrapper(*args, **kwargs): # func调用前扩展功能 # ... _r = func(*args, **kwargs) # func调用后扩展功能... # ... return _r return wrapper 以上就是一个不带参数装饰器的套路写法。from functools import wrapsdef decorate(*decorate_args, **decorate_kwargs): def real_decorate(func): @wraps(func) def wrapper(*args, **kwargs): # *decorate_args, **decorate_kwargs可以在这里直接使用 # func调用前功能 # ... _r = func(*args, **kwargs) # func调用后功能... # ... return _r return wrapper return real_decorate 以上就是一个带参数装饰器的套路写法。 详解接下来我来将这个 公式 的演进过程推导一下 在python中函数、方法都是一等对象，所以可以把函数和方法当成变量来看待，比如 def foo(a): return a + adouble = foodouble(11)# 22 这里将foo函数标志符赋值给double，这样就能像调用foo一样调用double了，而且这个时候删除foo，double依然可以使用。 del foofoo(10)# Traceback (most recent call last):# File "&lt;stdin&gt;", line 1, in &lt;module&gt;# NameError: name 'foo' is not defineddouble(4)# 8 能赋值，也能被作为参数传入函数，也能作为结果被返回。 def add(a, b): return a + bdef print_func_name((func): print(f"这个方法的名字是:&#123;func.__name__&#125;")# 将add这个函数作为参数传入print_func_name(add)# 这个方法的名字是:add# add函数作为结果被返回def give_me_add(): return addmyadd = give_me_add()myadd(2, 3)# 5 我们离装饰器不远了，现在我们回想一下装饰器的原理，其实就是将原函数重新包装一下，并且增加了一些功能。这里要用到一个python的特点：python允许在方法内定义方法。那么装饰器的基本思路我们就有了，我们将一个需要扩展的方法当作一个参数传入，然后对其进行包装，然后再返回包装后的函数。 # 我们要扩展的函数叫foodef foo(): print("I'm foo")def decorate(func): def wrapper(): return func() return wrapperdecorated_foo = decorate(foo)print(decorated_foo)# &lt;function decorate.&lt;locals&gt;.wrapper at 0x1035d9bf8&gt;# 注意这里是wrapper标识符哦！！decorated_foo()# 输出:I'm foo 梳理上面这段代码的含义。foo是我们需要扩展的函数。decorate函数接受一个方法作为参数传入，在decorate定义了一个wrapper对传进来的方法进行包装（这里什么都没做），最后返回了这个包装函数。那么我们在将foo传入decorate后会得到一个函数标识符的返回结果，调用这个结果就等于调用了wrapper，最终执行的就是wrapper里的逻辑了。这样就得到了我们想要扩展函数的目的。 装饰器返回的是内部函数的标识符，而总结里的from functools import wraps导入的wraps可以将装饰后的函数名字等一些信息保持不变。大家去试试吧。 接下来我们来个复杂一点点的，我们要为 add 函数加一个功能：输出传入它的参数，当然我们不希望去改动 add 函数本身: def add(a, b): return a + bdef decorate(func): # 刚刚我们知道，最终我们是调用了wrapper函数， # 所以有参数需要传入扩展函数，那么就在调用wrapper的时候传入，由wrapper传达给扩展函数 # 当然我们在不确定扩展函数的参数形态的时候 # 可以用*args, **kwargs来替代任何参数 def wrapper(a, b): print("传入参数: %s, %s" % (a, b)) _r = func(a, b) return _r return wrapperprint_param_add = decorate(add)print_param_add(1,3)# 传入参数: 1, 3# 4 这样我们就做好了一个最简单基础的装饰器了。为了达到 “装饰” 的效果，我们不希望“装饰“后的函数改变其名字，这个不难。 add = decorate(add) 这样我们就可以不改变其他地方调用add的代码，为add增加一些功能了。如同 i += 1 一样python为我们提供了一个语法糖来更加简单、直观地使用装饰器。 @decoratedef func(): pass# 等同于func = decorate(func) 以上就是一个简单装饰器的写法来了。在结论中另外一种是带参数的装饰器，里面用到了很深的一些python知识：闭包。 也可以简单的理解成，先用一个函数构建一个装饰器，而我们在装饰器上传入的参数能在构建出来的装饰器中“使用”。这里的使用是有局限性的，原因就需要你去理解闭包的相关知识了。用一段代码来简单说明： # 装饰器构建函数def decorate_builder(*n_args, **n_kwargs): def inner_decorate(func): # 不带参数装饰器的写法 # 在这里*n_args, **n_kwargs参数可以被使用 # ... return inner_decoratedecorate = decorate_builder(param1=None, param2=True) # 这里返回的是一个普通装饰器的标识符foo = decorate(foo) # 等同于 foo = decorate_builder(param1=None, param2=True)(foo)# 相当于@decorate_builder(param1=None, param2=True)def foo(): pass 小练习 有一个函数，返回传入的字符串。我们写个装饰器，将它打印的内容根据参数转换成大写或者小写。 def case(b): def inner_decorate(func): def wrapper(*args, **kwargs): _r = func(*args, **kwargs) if b == "lower": _r = _r.lower() elif b == "upper": _r = _r.upper() return _r return wrapper return inner_decorate@case("upper") # upper或者lowerdef output(s): return s]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JupyterWebsocketError]]></title>
    <url>%2F2019%2F03%2F04%2FJupyterWebsocketError%2F</url>
    <content type="text"><![CDATA[Jupyter启动时候websocket出现错误报错如下: c:\users\xxx\desktop\my-test-project\venv\lib\site-packages\notebook\base\zmqhandlers.py:284: RuntimeWarning: coroutine 'WebSocketHandler.get' was never awaited super(AuthenticatedZMQStreamHandler, self).get(*args, **kwargs) 解决方法Uninstall tornado 6 and reinstall tornado 5. sudo pip3 uninstall tornadosudo pip3 install tornado==5.1.1 Stackoverflow原帖]]></content>
  </entry>
  <entry>
    <title><![CDATA[LVM逻辑卷管理器]]></title>
    <url>%2F2018%2F12%2F19%2FLVM%E9%80%BB%E8%BE%91%E5%8D%B7%E7%AE%A1%E7%90%86%E5%99%A8%2F</url>
    <content type="text"><![CDATA[概要通过整合PV(Physical Volume)成VG(Volume Group)，再从VG中分割出LV(Logical Volume)，挂在LV来使用。 基础操作 创建pv pvcreate /dev/sdc 将pv加入vg中 # storage是vg卷名称vgcreate storage /dev/sdc 切割出lv # -n lv名称# 在对逻辑卷进行切割时有两种计量单位。# 第一种是以容量为单位，所使用的参数为-L。# 例如，使用-L 150M生成一个大小为150MB的逻辑卷。# 另外一种是以基本单元的个数为单位，所使用的参数为-l。每个基本单元的大小默认为4MB。# 例如，使用-l 37可以生成一个大小为37×4MB=148MB的逻辑卷。lvcreate -n vo -l 37 storage 格式化、挂载 mkfs.ext4 /dev/storage/vomkdir /datamount /dev/storage/vo /data 写入配置文件，永久生效 echo "/dev/storage/vo /data ext4 defaults 0 0" &gt;&gt; /etc/fstab 基础命令 功能/命令 物理卷管理 卷组管理 逻辑卷管理 扫描 pvscan vgscan lvscan 建立 pvcreate vgcreate lvcreate 显示 pvdisplay vgdisplay lvdisplay 删除 pvremove vgremove lvremove 扩展 vgextend lvextend 缩小 vgreduce lvreduce 参考资料]]></content>
  </entry>
  <entry>
    <title><![CDATA[写个过滤器]]></title>
    <url>%2F2018%2F05%2F27%2F%E5%86%99%E4%B8%AA%E8%BF%87%E6%BB%A4%E5%99%A8%2F</url>
    <content type="text"><![CDATA[类的继承写个过滤器基类class Filter: def __init__(self): self._filter_list = [] def filter(self, seq): return [i for i in seq if not i in self._filter_list] 这个类没有办法过滤任何东西，下面来做一个能用的过滤器。 制造一个有用的过滤器新建一个类继承于刚刚的Filter，在__init__方法中加入过滤列表。 class Dollar_Filter(Filter): def __init__(self): self._filter_list = ['$']&gt;&gt;&gt;dollar_filter = Dollar_Filter()&gt;&gt;&gt;dollar_filter.filter([1, 2, 3, 'asdf', '$', 'sx', '%', 'ff', '$'])[1, 2, 3, 'asdf', '$', 'sx', '%', 'ff', '$'] 抽象思维在面向对象和函数编程中抽象思维十分重要，它能让代码复用性更高、耦合度更低。 参考上述例子来自于《Python基础教程（第2版）》]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python嵌套列表初始化]]></title>
    <url>%2F2018%2F01%2F30%2FPython%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[始于2048游戏的一个问题在写2048的时候，需要写一个4*4的游戏棋盘。最容易实现的方法就是二维数组，例如用 a[x][y] 来表示一个游戏棋盘的格子。然后用赋值的方法给格子填充数字。当时的实现方法如下： a = [['_'] * 4 ] * 4# [['_', '_', '_', '_'],# ['_', '_', '_', '_'],# ['_', '_', '_', '_'],# ['_', '_', '_', '_']]a[1][2] = 'X' # 2行3列填充'X'# [['_', '_', 'X', '_'],# ['_', '_', 'X', '_'],# ['_', '_', 'X', '_'],# ['_', '_', 'X', '_']] 流畅的Python由于仅仅只做了一步赋值动作，所以怎么想都没想明白，抱着侥幸的心里查看了一下《流畅的python》，果然发现了案例，描述的问题一模一样。书中给出的方法是（书中是3*3的棋盘）： a = [['_'] * 3 for i in range(3)]# [['_', '_', '_'],# ['_', '_', '_'],# ['_', '_', '_']]a[1][2] = 'X' # 2行3列填充'X'# [['_', '_', '_'],# ['_', '_', 'X'],# ['_', '_', '_']] 原因通过[[&#39;_&#39;] * 4 ] * 4生成的列表中的元素其实是指向同一列表的三个list，他们的id是相同的 In [10]: a = [['_'] * 4 ] * 4In [11]: id(a[0])Out[11]: 67027552In [12]: id(a[1])Out[12]: 67027552In [13]: id(a[2])Out[13]: 67027552In [14]: id(a[3])Out[14]: 67027552 所以出现了上面的情况，为其中一个元素赋值的时候同时改变了其他的list。 当然也可以用以下方法生成list： b = [] for i in range(4): row = ['_'] * 4 b.append(row) for循环中每次循环会产生一个新的row。]]></content>
      <tags>
        <tag>python</tag>
        <tag>数据格式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[skill_stack]]></title>
    <url>%2F2018%2F01%2F10%2Fskill-stack%2F</url>
    <content type="text"><![CDATA[技术栈新年开始先埋点坑。 DevOps Errbot 机器人 StackStorm 将操作原子化自由组合的DevOps工具 Rocket.Chat 开源聊天室 Python circus python3下可以用来代替supervisor click 命令行工具 fire 自动生成命令行 pipenv python官方推荐的包、虚拟环境、python版本管理工具]]></content>
      <tags>
        <tag>python</tag>
        <tag>DevOps</tag>
      </tags>
  </entry>
</search>
