<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LVM逻辑卷管理器]]></title>
    <url>%2F2018%2F12%2F19%2FLVM%E9%80%BB%E8%BE%91%E5%8D%B7%E7%AE%A1%E7%90%86%E5%99%A8%2F</url>
    <content type="text"><![CDATA[概要通过整合PV(Physical Volume)成VG(Volume Group)，再从VG中分割出LV(Logical Volume)，挂在LV来使用。 基础操作 创建pv 1pvcreate /dev/sdc 将pv加入vg中 12# storage是vg卷名称vgcreate storage /dev/sdc 切割出lv 1234567# -n lv名称# 在对逻辑卷进行切割时有两种计量单位。# 第一种是以容量为单位，所使用的参数为-L。# 例如，使用-L 150M生成一个大小为150MB的逻辑卷。# 另外一种是以基本单元的个数为单位，所使用的参数为-l。每个基本单元的大小默认为4MB。# 例如，使用-l 37可以生成一个大小为37×4MB=148MB的逻辑卷。lvcreate -n vo -l 37 storage 格式化、挂载 123mkfs.ext4 /dev/storage/vomkdir /datamount /dev/storage/vo /data 写入配置文件，永久生效 1echo "/dev/storage/vo /data ext4 defaults 0 0" &gt;&gt; /etc/fstab 基础命令 功能/命令 物理卷管理 卷组管理 逻辑卷管理 扫描 pvscan vgscan lvscan 建立 pvcreate vgcreate lvcreate 显示 pvdisplay vgdisplay lvdisplay 删除 pvremove vgremove lvremove 扩展 vgextend lvextend 缩小 vgreduce lvreduce 参考资料]]></content>
  </entry>
  <entry>
    <title><![CDATA[写个过滤器]]></title>
    <url>%2F2018%2F05%2F27%2F%E5%86%99%E4%B8%AA%E8%BF%87%E6%BB%A4%E5%99%A8%2F</url>
    <content type="text"><![CDATA[类的继承写个过滤器基类12345class Filter: def __init__(self): self._filter_list = [] def filter(self, seq): return [i for i in seq if not i in self._filter_list] 这个类没有办法过滤任何东西，下面来做一个能用的过滤器。 制造一个有用的过滤器新建一个类继承于刚刚的Filter，在__init__方法中加入过滤列表。 1234567class Dollar_Filter(Filter): def __init__(self): self._filter_list = ['$']&gt;&gt;&gt;dollar_filter = Dollar_Filter()&gt;&gt;&gt;dollar_filter.filter([1, 2, 3, 'asdf', '$', 'sx', '%', 'ff', '$'])[1, 2, 3, 'asdf', '$', 'sx', '%', 'ff', '$'] 抽象思维在面向对象和函数编程中抽象思维十分重要，它能让代码复用性更高、耦合度更低。 参考上述例子来自于《Python基础教程（第2版）》]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python嵌套列表初始化]]></title>
    <url>%2F2018%2F01%2F30%2FPython%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[始于2048游戏的一个问题在写2048的时候，需要写一个4*4的游戏棋盘。最容易实现的方法就是二维数组，例如用 a[x][y] 来表示一个游戏棋盘的格子。然后用赋值的方法给格子填充数字。当时的实现方法如下： 1234567891011a = [['_'] * 4 ] * 4# [['_', '_', '_', '_'],# ['_', '_', '_', '_'],# ['_', '_', '_', '_'],# ['_', '_', '_', '_']]a[1][2] = 'X' # 2行3列填充'X'# [['_', '_', 'X', '_'],# ['_', '_', 'X', '_'],# ['_', '_', 'X', '_'],# ['_', '_', 'X', '_']] 流畅的Python由于仅仅只做了一步赋值动作，所以怎么想都没想明白，抱着侥幸的心里查看了一下《流畅的python》，果然发现了案例，描述的问题一模一样。书中给出的方法是（书中是3*3的棋盘）： 123456789a = [['_'] * 3 for i in range(3)]# [['_', '_', '_'],# ['_', '_', '_'],# ['_', '_', '_']]a[1][2] = 'X' # 2行3列填充'X'# [['_', '_', '_'],# ['_', '_', 'X'],# ['_', '_', '_']] 原因通过[[&#39;_&#39;] * 4 ] * 4生成的列表中的元素其实是指向同一列表的三个list，他们的id是相同的 12345678910111213In [10]: a = [['_'] * 4 ] * 4In [11]: id(a[0])Out[11]: 67027552In [12]: id(a[1])Out[12]: 67027552In [13]: id(a[2])Out[13]: 67027552In [14]: id(a[3])Out[14]: 67027552 所以出现了上面的情况，为其中一个元素赋值的时候同时改变了其他的list。 当然也可以用以下方法生成list： b = [] for i in range(4): row = ['_'] * 4 b.append(row) for循环中每次循环会产生一个新的row。]]></content>
      <tags>
        <tag>python</tag>
        <tag>数据格式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[skill_stack]]></title>
    <url>%2F2018%2F01%2F10%2Fskill-stack%2F</url>
    <content type="text"><![CDATA[技术栈新年开始先埋点坑。 DevOps Errbot 机器人 StackStorm 将操作原子化自由组合的DevOps工具 Rocket.Chat 开源聊天室 Python circus python3下可以用来代替supervisor click 命令行工具 fire 自动生成命令行 pipenv python官方推荐的包、虚拟环境、python版本管理工具]]></content>
      <tags>
        <tag>python</tag>
        <tag>DevOps</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F11%2F30%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
