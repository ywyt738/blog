<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[写一个python装饰器]]></title>
    <url>%2F2019%2F04%2F28%2F%E5%86%99%E4%B8%80%E4%B8%AApython%E8%A3%85%E9%A5%B0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[装饰器的用途装饰器的主要作用在于对现有方法、函数进行一定的扩展，简单的说就是在原有函数、方法调用前、后去添加一些额外的功能。至于更高层次的用法，我们就不深讨论了。今天只说一些简单的。 结论先出结论，装饰器的写法是有一定规律的，可以按照以下 公式 来套用。 1234567891011121314from functools import wrapsdef decorate(func): @wraps(func) def wrapper(*args, **kwargs): # func调用前扩展功能 # ... _r = func(*args, **kwargs) # func调用后扩展功能... # ... return _r return wrapper 以上就是一个不带参数装饰器的套路写法。 12345678910111213141516171819from functools import wrapsdef decorate(*decorate_args, **decorate_kwargs): def real_decorate(func): @wraps(func) def wrapper(*args, **kwargs): # *decorate_args, **decorate_kwargs可以在这里直接使用 # func调用前功能 # ... _r = func(*args, **kwargs) # func调用后功能... # ... return _r return wrapper return real_decorate 以上就是一个带参数装饰器的套路写法。 详解接下来我来将这个 公式 的演进过程推导一下 在python中函数、方法都是一等对象，所以可以把函数和方法当成变量来看待，比如 1234567def foo(a): return a + adouble = foodouble(11)# 22 这里将foo函数标志符赋值给double，这样就能像调用foo一样调用double了，而且这个时候删除foo，double依然可以使用。 12345678del foofoo(10)# Traceback (most recent call last):# File "&lt;stdin&gt;", line 1, in &lt;module&gt;# NameError: name 'foo' is not defineddouble(4)# 8 能赋值，也能被作为参数传入函数，也能作为结果被返回。 1234567891011121314151617def add(a, b): return a + bdef print_func_name((func): print(f"这个方法的名字是:&#123;func.__name__&#125;")# 将add这个函数作为参数传入print_func_name(add)# 这个方法的名字是:add# add函数作为结果被返回def give_me_add(): return addmyadd = give_me_add()myadd(2, 3)# 5 我们离装饰器不远了，现在我们回想一下装饰器的原理，其实就是将原函数重新包装一下，并且增加了一些功能。这里要用到一个python的特点：python允许在方法内定义方法。那么装饰器的基本思路我们就有了，我们将一个需要扩展的方法当作一个参数传入，然后对其进行包装，然后再返回包装后的函数。 123456789101112131415# 我们要扩展的函数叫foodef foo(): print("I'm foo")def decorate(func): def wrapper(): return func() return wrapperdecorated_foo = decorate(foo)print(decorated_foo)# &lt;function decorate.&lt;locals&gt;.wrapper at 0x1035d9bf8&gt;# 注意这里是wrapper标识符哦！！decorated_foo()# 输出:I'm foo 梳理上面这段代码的含义。foo是我们需要扩展的函数。decorate函数接受一个方法作为参数传入，在decorate定义了一个wrapper对传进来的方法进行包装（这里什么都没做），最后返回了这个包装函数。那么我们在将foo传入decorate后会得到一个函数标识符的返回结果，调用这个结果就等于调用了wrapper，最终执行的就是wrapper里的逻辑了。这样就得到了我们想要扩展函数的目的。 装饰器返回的是内部函数的标识符，而总结里的from functools import wraps导入的wraps可以将装饰后的函数名字等一些信息保持不变。大家去试试吧。 接下来我们来个复杂一点点的，我们要为 add 函数加一个功能：输出传入它的参数，当然我们不希望去改动 add 函数本身: 123456789101112131415161718def add(a, b): return a + bdef decorate(func): # 刚刚我们知道，最终我们是调用了wrapper函数， # 所以有参数需要传入扩展函数，那么就在调用wrapper的时候传入，由wrapper传达给扩展函数 # 当然我们在不确定扩展函数的参数形态的时候 # 可以用*args, **kwargs来替代任何参数 def wrapper(a, b): print("传入参数: %s, %s" % (a, b)) _r = func(a, b) return _r return wrapperprint_param_add = decorate(add)print_param_add(1,3)# 传入参数: 1, 3# 4 这样我们就做好了一个最简单基础的装饰器了。为了达到 “装饰” 的效果，我们不希望“装饰“后的函数改变其名字，这个不难。 1add = decorate(add) 这样我们就可以不改变其他地方调用add的代码，为add增加一些功能了。如同 i += 1 一样python为我们提供了一个语法糖来更加简单、直观地使用装饰器。 123456@decoratedef func(): pass# 等同于func = decorate(func) 以上就是一个简单装饰器的写法来了。在结论中另外一种是带参数的装饰器，里面用到了很深的一些python知识：闭包。 也可以简单的理解成，先用一个函数构建一个装饰器，而我们在装饰器上传入的参数能在构建出来的装饰器中“使用”。这里的使用是有局限性的，原因就需要你去理解闭包的相关知识了。用一段代码来简单说明： 1234567891011121314151617# 装饰器构建函数def decorate_builder(*n_args, **n_kwargs): def inner_decorate(func): # 不带参数装饰器的写法 # 在这里*n_args, **n_kwargs参数可以被使用 # ... return inner_decoratedecorate = decorate_builder(param1=None, param2=True) # 这里返回的是一个普通装饰器的标识符foo = decorate(foo) # 等同于 foo = decorate_builder(param1=None, param2=True)(foo)# 相当于@decorate_builder(param1=None, param2=True)def foo(): pass 小练习 有一个函数，返回传入的字符串。我们写个装饰器，将它打印的内容根据参数转换成大写或者小写。 123456789101112131415161718def case(b): def inner_decorate(func): def wrapper(*args, **kwargs): _r = func(*args, **kwargs) if b == "lower": _r = _r.lower() elif b == "upper": _r = _r.upper() return _r return wrapper return inner_decorate@case("upper") # upper或者lowerdef output(s): return s]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JupyterWebsocketError]]></title>
    <url>%2F2019%2F03%2F04%2FJupyterWebsocketError%2F</url>
    <content type="text"><![CDATA[Jupyter启动时候websocket出现错误报错如下: 12c:\users\xxx\desktop\my-test-project\venv\lib\site-packages\notebook\base\zmqhandlers.py:284: RuntimeWarning: coroutine 'WebSocketHandler.get' was never awaited super(AuthenticatedZMQStreamHandler, self).get(*args, **kwargs) 解决方法Uninstall tornado 6 and reinstall tornado 5. 12sudo pip3 uninstall tornadosudo pip3 install tornado==5.1.1 Stackoverflow原帖]]></content>
  </entry>
  <entry>
    <title><![CDATA[LVM逻辑卷管理器]]></title>
    <url>%2F2018%2F12%2F19%2FLVM%E9%80%BB%E8%BE%91%E5%8D%B7%E7%AE%A1%E7%90%86%E5%99%A8%2F</url>
    <content type="text"><![CDATA[概要通过整合PV(Physical Volume)成VG(Volume Group)，再从VG中分割出LV(Logical Volume)，挂在LV来使用。 基础操作 创建pv 1pvcreate /dev/sdc 将pv加入vg中 12# storage是vg卷名称vgcreate storage /dev/sdc 切割出lv 1234567# -n lv名称# 在对逻辑卷进行切割时有两种计量单位。# 第一种是以容量为单位，所使用的参数为-L。# 例如，使用-L 150M生成一个大小为150MB的逻辑卷。# 另外一种是以基本单元的个数为单位，所使用的参数为-l。每个基本单元的大小默认为4MB。# 例如，使用-l 37可以生成一个大小为37×4MB=148MB的逻辑卷。lvcreate -n vo -l 37 storage 格式化、挂载 123mkfs.ext4 /dev/storage/vomkdir /datamount /dev/storage/vo /data 写入配置文件，永久生效 1echo "/dev/storage/vo /data ext4 defaults 0 0" &gt;&gt; /etc/fstab 基础命令 功能/命令 物理卷管理 卷组管理 逻辑卷管理 扫描 pvscan vgscan lvscan 建立 pvcreate vgcreate lvcreate 显示 pvdisplay vgdisplay lvdisplay 删除 pvremove vgremove lvremove 扩展 vgextend lvextend 缩小 vgreduce lvreduce 参考资料]]></content>
  </entry>
  <entry>
    <title><![CDATA[写个过滤器]]></title>
    <url>%2F2018%2F05%2F27%2F%E5%86%99%E4%B8%AA%E8%BF%87%E6%BB%A4%E5%99%A8%2F</url>
    <content type="text"><![CDATA[类的继承写个过滤器基类12345class Filter: def __init__(self): self._filter_list = [] def filter(self, seq): return [i for i in seq if not i in self._filter_list] 这个类没有办法过滤任何东西，下面来做一个能用的过滤器。 制造一个有用的过滤器新建一个类继承于刚刚的Filter，在__init__方法中加入过滤列表。 1234567class Dollar_Filter(Filter): def __init__(self): self._filter_list = ['$']&gt;&gt;&gt;dollar_filter = Dollar_Filter()&gt;&gt;&gt;dollar_filter.filter([1, 2, 3, 'asdf', '$', 'sx', '%', 'ff', '$'])[1, 2, 3, 'asdf', '$', 'sx', '%', 'ff', '$'] 抽象思维在面向对象和函数编程中抽象思维十分重要，它能让代码复用性更高、耦合度更低。 参考上述例子来自于《Python基础教程（第2版）》]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python嵌套列表初始化]]></title>
    <url>%2F2018%2F01%2F30%2FPython%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[始于2048游戏的一个问题在写2048的时候，需要写一个4*4的游戏棋盘。最容易实现的方法就是二维数组，例如用 a[x][y] 来表示一个游戏棋盘的格子。然后用赋值的方法给格子填充数字。当时的实现方法如下： 1234567891011a = [['_'] * 4 ] * 4# [['_', '_', '_', '_'],# ['_', '_', '_', '_'],# ['_', '_', '_', '_'],# ['_', '_', '_', '_']]a[1][2] = 'X' # 2行3列填充'X'# [['_', '_', 'X', '_'],# ['_', '_', 'X', '_'],# ['_', '_', 'X', '_'],# ['_', '_', 'X', '_']] 流畅的Python由于仅仅只做了一步赋值动作，所以怎么想都没想明白，抱着侥幸的心里查看了一下《流畅的python》，果然发现了案例，描述的问题一模一样。书中给出的方法是（书中是3*3的棋盘）： 123456789a = [['_'] * 3 for i in range(3)]# [['_', '_', '_'],# ['_', '_', '_'],# ['_', '_', '_']]a[1][2] = 'X' # 2行3列填充'X'# [['_', '_', '_'],# ['_', '_', 'X'],# ['_', '_', '_']] 原因通过[[&#39;_&#39;] * 4 ] * 4生成的列表中的元素其实是指向同一列表的三个list，他们的id是相同的 12345678910111213In [10]: a = [['_'] * 4 ] * 4In [11]: id(a[0])Out[11]: 67027552In [12]: id(a[1])Out[12]: 67027552In [13]: id(a[2])Out[13]: 67027552In [14]: id(a[3])Out[14]: 67027552 所以出现了上面的情况，为其中一个元素赋值的时候同时改变了其他的list。 当然也可以用以下方法生成list： b = [] for i in range(4): row = ['_'] * 4 b.append(row) for循环中每次循环会产生一个新的row。]]></content>
      <tags>
        <tag>python</tag>
        <tag>数据格式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[skill_stack]]></title>
    <url>%2F2018%2F01%2F10%2Fskill-stack%2F</url>
    <content type="text"><![CDATA[技术栈新年开始先埋点坑。 DevOps Errbot 机器人 StackStorm 将操作原子化自由组合的DevOps工具 Rocket.Chat 开源聊天室 Python circus python3下可以用来代替supervisor click 命令行工具 fire 自动生成命令行 pipenv python官方推荐的包、虚拟环境、python版本管理工具]]></content>
      <tags>
        <tag>python</tag>
        <tag>DevOps</tag>
      </tags>
  </entry>
</search>
